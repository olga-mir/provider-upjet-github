/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BranchNamePatternInitParameters struct {

	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type BranchNamePatternObservation struct {

	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type BranchNamePatternParameters struct {

	// How this rule will appear to users.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// If true, the rule will fail if the pattern matches.
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// The pattern to match with.
	// +kubebuilder:validation:Optional
	Pattern *string `json:"pattern" tf:"pattern,omitempty"`
}

type BypassActorsInitParameters struct {

	// The ID of the actor that can bypass a ruleset. When `actor_type` is `OrganizationAdmin`, this should be set to `1`.
	ActorID *int64 `json:"actorId,omitempty" tf:"actor_id,omitempty"`

	// The type of actor that can bypass a ruleset. Can be one of: `RepositoryRole`, `Team`, `Integration`, `OrganizationAdmin`.
	ActorType *string `json:"actorType,omitempty" tf:"actor_type,omitempty"`

	// When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: `always`, `pull_request`.
	BypassMode *string `json:"bypassMode,omitempty" tf:"bypass_mode,omitempty"`
}

type BypassActorsObservation struct {

	// The ID of the actor that can bypass a ruleset. When `actor_type` is `OrganizationAdmin`, this should be set to `1`.
	ActorID *int64 `json:"actorId,omitempty" tf:"actor_id,omitempty"`

	// The type of actor that can bypass a ruleset. Can be one of: `RepositoryRole`, `Team`, `Integration`, `OrganizationAdmin`.
	ActorType *string `json:"actorType,omitempty" tf:"actor_type,omitempty"`

	// When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: `always`, `pull_request`.
	BypassMode *string `json:"bypassMode,omitempty" tf:"bypass_mode,omitempty"`
}

type BypassActorsParameters struct {

	// The ID of the actor that can bypass a ruleset. When `actor_type` is `OrganizationAdmin`, this should be set to `1`.
	// +kubebuilder:validation:Optional
	ActorID *int64 `json:"actorId" tf:"actor_id,omitempty"`

	// The type of actor that can bypass a ruleset. Can be one of: `RepositoryRole`, `Team`, `Integration`, `OrganizationAdmin`.
	// +kubebuilder:validation:Optional
	ActorType *string `json:"actorType" tf:"actor_type,omitempty"`

	// When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: `always`, `pull_request`.
	// +kubebuilder:validation:Optional
	BypassMode *string `json:"bypassMode" tf:"bypass_mode,omitempty"`
}

type CommitAuthorEmailPatternInitParameters struct {

	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type CommitAuthorEmailPatternObservation struct {

	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type CommitAuthorEmailPatternParameters struct {

	// How this rule will appear to users.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// If true, the rule will fail if the pattern matches.
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// The pattern to match with.
	// +kubebuilder:validation:Optional
	Pattern *string `json:"pattern" tf:"pattern,omitempty"`
}

type CommitMessagePatternInitParameters struct {

	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type CommitMessagePatternObservation struct {

	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type CommitMessagePatternParameters struct {

	// How this rule will appear to users.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// If true, the rule will fail if the pattern matches.
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// The pattern to match with.
	// +kubebuilder:validation:Optional
	Pattern *string `json:"pattern" tf:"pattern,omitempty"`
}

type CommitterEmailPatternInitParameters struct {

	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type CommitterEmailPatternObservation struct {

	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type CommitterEmailPatternParameters struct {

	// How this rule will appear to users.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// If true, the rule will fail if the pattern matches.
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// The pattern to match with.
	// +kubebuilder:validation:Optional
	Pattern *string `json:"pattern" tf:"pattern,omitempty"`
}

type ConditionsInitParameters struct {
	RefName []RefNameInitParameters `json:"refName,omitempty" tf:"ref_name,omitempty"`

	// The repository IDs that the ruleset applies to. One of these IDs must match for the condition to pass.
	RepositoryID []*int64 `json:"repositoryId,omitempty" tf:"repository_id,omitempty"`

	RepositoryName []RepositoryNameInitParameters `json:"repositoryName,omitempty" tf:"repository_name,omitempty"`
}

type ConditionsObservation struct {
	RefName []RefNameObservation `json:"refName,omitempty" tf:"ref_name,omitempty"`

	// The repository IDs that the ruleset applies to. One of these IDs must match for the condition to pass.
	RepositoryID []*int64 `json:"repositoryId,omitempty" tf:"repository_id,omitempty"`

	RepositoryName []RepositoryNameObservation `json:"repositoryName,omitempty" tf:"repository_name,omitempty"`
}

type ConditionsParameters struct {

	// +kubebuilder:validation:Optional
	RefName []RefNameParameters `json:"refName" tf:"ref_name,omitempty"`

	// The repository IDs that the ruleset applies to. One of these IDs must match for the condition to pass.
	// +kubebuilder:validation:Optional
	RepositoryID []*int64 `json:"repositoryId,omitempty" tf:"repository_id,omitempty"`

	// +kubebuilder:validation:Optional
	RepositoryName []RepositoryNameParameters `json:"repositoryName,omitempty" tf:"repository_name,omitempty"`
}

type OrganizationRulesetInitParameters struct {

	// The actors that can bypass the rules in this ruleset.
	BypassActors []BypassActorsInitParameters `json:"bypassActors,omitempty" tf:"bypass_actors,omitempty"`

	// Parameters for an organization ruleset condition. `ref_name` is required alongside one of `repository_name` or `repository_id`.
	Conditions []ConditionsInitParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// Possible values for Enforcement are `disabled`, `active`, `evaluate`. Note: `evaluate` is currently only supported for owners of type `organization`.
	Enforcement *string `json:"enforcement,omitempty" tf:"enforcement,omitempty"`

	// The name of the ruleset.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Rules within the ruleset.
	Rules []RulesInitParameters `json:"rules,omitempty" tf:"rules,omitempty"`

	// Possible values are `branch`, `tag` and `push`. Note: The `push` target is in beta and is subject to change.
	Target *string `json:"target,omitempty" tf:"target,omitempty"`
}

type OrganizationRulesetObservation struct {

	// The actors that can bypass the rules in this ruleset.
	BypassActors []BypassActorsObservation `json:"bypassActors,omitempty" tf:"bypass_actors,omitempty"`

	// Parameters for an organization ruleset condition. `ref_name` is required alongside one of `repository_name` or `repository_id`.
	Conditions []ConditionsObservation `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// Possible values for Enforcement are `disabled`, `active`, `evaluate`. Note: `evaluate` is currently only supported for owners of type `organization`.
	Enforcement *string `json:"enforcement,omitempty" tf:"enforcement,omitempty"`

	Etag *string `json:"etag,omitempty" tf:"etag,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The name of the ruleset.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// GraphQL global node id for use with v4 API.
	NodeID *string `json:"nodeId,omitempty" tf:"node_id,omitempty"`

	// Rules within the ruleset.
	Rules []RulesObservation `json:"rules,omitempty" tf:"rules,omitempty"`

	// GitHub ID for the ruleset.
	RulesetID *int64 `json:"rulesetId,omitempty" tf:"ruleset_id,omitempty"`

	// Possible values are `branch`, `tag` and `push`. Note: The `push` target is in beta and is subject to change.
	Target *string `json:"target,omitempty" tf:"target,omitempty"`
}

type OrganizationRulesetParameters struct {

	// The actors that can bypass the rules in this ruleset.
	// +kubebuilder:validation:Optional
	BypassActors []BypassActorsParameters `json:"bypassActors,omitempty" tf:"bypass_actors,omitempty"`

	// Parameters for an organization ruleset condition. `ref_name` is required alongside one of `repository_name` or `repository_id`.
	// +kubebuilder:validation:Optional
	Conditions []ConditionsParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// Possible values for Enforcement are `disabled`, `active`, `evaluate`. Note: `evaluate` is currently only supported for owners of type `organization`.
	// +kubebuilder:validation:Optional
	Enforcement *string `json:"enforcement,omitempty" tf:"enforcement,omitempty"`

	// The name of the ruleset.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Rules within the ruleset.
	// +kubebuilder:validation:Optional
	Rules []RulesParameters `json:"rules,omitempty" tf:"rules,omitempty"`

	// Possible values are `branch`, `tag` and `push`. Note: The `push` target is in beta and is subject to change.
	// +kubebuilder:validation:Optional
	Target *string `json:"target,omitempty" tf:"target,omitempty"`
}

type PullRequestInitParameters struct {

	// New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to `false`.
	DismissStaleReviewsOnPush *bool `json:"dismissStaleReviewsOnPush,omitempty" tf:"dismiss_stale_reviews_on_push,omitempty"`

	// Require an approving review in pull requests that modify files that have a designated code owner. Defaults to `false`.
	RequireCodeOwnerReview *bool `json:"requireCodeOwnerReview,omitempty" tf:"require_code_owner_review,omitempty"`

	// Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to `false`.
	RequireLastPushApproval *bool `json:"requireLastPushApproval,omitempty" tf:"require_last_push_approval,omitempty"`

	// The number of approving reviews that are required before a pull request can be merged. Defaults to `0`.
	RequiredApprovingReviewCount *int64 `json:"requiredApprovingReviewCount,omitempty" tf:"required_approving_review_count,omitempty"`

	// All conversations on code must be resolved before a pull request can be merged. Defaults to `false`.
	RequiredReviewThreadResolution *bool `json:"requiredReviewThreadResolution,omitempty" tf:"required_review_thread_resolution,omitempty"`
}

type PullRequestObservation struct {

	// New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to `false`.
	DismissStaleReviewsOnPush *bool `json:"dismissStaleReviewsOnPush,omitempty" tf:"dismiss_stale_reviews_on_push,omitempty"`

	// Require an approving review in pull requests that modify files that have a designated code owner. Defaults to `false`.
	RequireCodeOwnerReview *bool `json:"requireCodeOwnerReview,omitempty" tf:"require_code_owner_review,omitempty"`

	// Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to `false`.
	RequireLastPushApproval *bool `json:"requireLastPushApproval,omitempty" tf:"require_last_push_approval,omitempty"`

	// The number of approving reviews that are required before a pull request can be merged. Defaults to `0`.
	RequiredApprovingReviewCount *int64 `json:"requiredApprovingReviewCount,omitempty" tf:"required_approving_review_count,omitempty"`

	// All conversations on code must be resolved before a pull request can be merged. Defaults to `false`.
	RequiredReviewThreadResolution *bool `json:"requiredReviewThreadResolution,omitempty" tf:"required_review_thread_resolution,omitempty"`
}

type PullRequestParameters struct {

	// New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to `false`.
	// +kubebuilder:validation:Optional
	DismissStaleReviewsOnPush *bool `json:"dismissStaleReviewsOnPush,omitempty" tf:"dismiss_stale_reviews_on_push,omitempty"`

	// Require an approving review in pull requests that modify files that have a designated code owner. Defaults to `false`.
	// +kubebuilder:validation:Optional
	RequireCodeOwnerReview *bool `json:"requireCodeOwnerReview,omitempty" tf:"require_code_owner_review,omitempty"`

	// Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to `false`.
	// +kubebuilder:validation:Optional
	RequireLastPushApproval *bool `json:"requireLastPushApproval,omitempty" tf:"require_last_push_approval,omitempty"`

	// The number of approving reviews that are required before a pull request can be merged. Defaults to `0`.
	// +kubebuilder:validation:Optional
	RequiredApprovingReviewCount *int64 `json:"requiredApprovingReviewCount,omitempty" tf:"required_approving_review_count,omitempty"`

	// All conversations on code must be resolved before a pull request can be merged. Defaults to `false`.
	// +kubebuilder:validation:Optional
	RequiredReviewThreadResolution *bool `json:"requiredReviewThreadResolution,omitempty" tf:"required_review_thread_resolution,omitempty"`
}

type RefNameInitParameters struct {

	// Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
	Exclude []*string `json:"exclude,omitempty" tf:"exclude,omitempty"`

	// Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`
}

type RefNameObservation struct {

	// Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
	Exclude []*string `json:"exclude,omitempty" tf:"exclude,omitempty"`

	// Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`
}

type RefNameParameters struct {

	// Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
	// +kubebuilder:validation:Optional
	Exclude []*string `json:"exclude" tf:"exclude,omitempty"`

	// Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
	// +kubebuilder:validation:Optional
	Include []*string `json:"include" tf:"include,omitempty"`
}

type RepositoryNameInitParameters struct {

	// Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match.
	Exclude []*string `json:"exclude,omitempty" tf:"exclude,omitempty"`

	// Array of repository names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~ALL` to include all repositories.
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`

	// Whether renaming of target repositories is prevented.
	Protected *bool `json:"protected,omitempty" tf:"protected,omitempty"`
}

type RepositoryNameObservation struct {

	// Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match.
	Exclude []*string `json:"exclude,omitempty" tf:"exclude,omitempty"`

	// Array of repository names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~ALL` to include all repositories.
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`

	// Whether renaming of target repositories is prevented.
	Protected *bool `json:"protected,omitempty" tf:"protected,omitempty"`
}

type RepositoryNameParameters struct {

	// Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match.
	// +kubebuilder:validation:Optional
	Exclude []*string `json:"exclude" tf:"exclude,omitempty"`

	// Array of repository names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~ALL` to include all repositories.
	// +kubebuilder:validation:Optional
	Include []*string `json:"include" tf:"include,omitempty"`

	// Whether renaming of target repositories is prevented.
	// +kubebuilder:validation:Optional
	Protected *bool `json:"protected,omitempty" tf:"protected,omitempty"`
}

type RequiredCheckInitParameters struct {

	// The status check context name that must be present on the commit.
	Context *string `json:"context,omitempty" tf:"context,omitempty"`

	// The optional integration ID that this status check must originate from.
	IntegrationID *int64 `json:"integrationId,omitempty" tf:"integration_id,omitempty"`
}

type RequiredCheckObservation struct {

	// The status check context name that must be present on the commit.
	Context *string `json:"context,omitempty" tf:"context,omitempty"`

	// The optional integration ID that this status check must originate from.
	IntegrationID *int64 `json:"integrationId,omitempty" tf:"integration_id,omitempty"`
}

type RequiredCheckParameters struct {

	// The status check context name that must be present on the commit.
	// +kubebuilder:validation:Optional
	Context *string `json:"context" tf:"context,omitempty"`

	// The optional integration ID that this status check must originate from.
	// +kubebuilder:validation:Optional
	IntegrationID *int64 `json:"integrationId,omitempty" tf:"integration_id,omitempty"`
}

type RequiredCodeScanningInitParameters struct {

	// Tools that must provide code scanning results for this rule to pass.
	RequiredCodeScanningTool []RequiredCodeScanningToolInitParameters `json:"requiredCodeScanningTool,omitempty" tf:"required_code_scanning_tool,omitempty"`
}

type RequiredCodeScanningObservation struct {

	// Tools that must provide code scanning results for this rule to pass.
	RequiredCodeScanningTool []RequiredCodeScanningToolObservation `json:"requiredCodeScanningTool,omitempty" tf:"required_code_scanning_tool,omitempty"`
}

type RequiredCodeScanningParameters struct {

	// Tools that must provide code scanning results for this rule to pass.
	// +kubebuilder:validation:Optional
	RequiredCodeScanningTool []RequiredCodeScanningToolParameters `json:"requiredCodeScanningTool" tf:"required_code_scanning_tool,omitempty"`
}

type RequiredCodeScanningToolInitParameters struct {

	// The severity level at which code scanning results that raise alerts block a reference update. Can be one of: `none`, `errors`, `errors_and_warnings`, `all`.
	AlertsThreshold *string `json:"alertsThreshold,omitempty" tf:"alerts_threshold,omitempty"`

	// The severity level at which code scanning results that raise security alerts block a reference update. Can be one of: `none`, `critical`, `high_or_higher`, `medium_or_higher`, `all`.
	SecurityAlertsThreshold *string `json:"securityAlertsThreshold,omitempty" tf:"security_alerts_threshold,omitempty"`

	// The name of a code scanning tool.
	Tool *string `json:"tool,omitempty" tf:"tool,omitempty"`
}

type RequiredCodeScanningToolObservation struct {

	// The severity level at which code scanning results that raise alerts block a reference update. Can be one of: `none`, `errors`, `errors_and_warnings`, `all`.
	AlertsThreshold *string `json:"alertsThreshold,omitempty" tf:"alerts_threshold,omitempty"`

	// The severity level at which code scanning results that raise security alerts block a reference update. Can be one of: `none`, `critical`, `high_or_higher`, `medium_or_higher`, `all`.
	SecurityAlertsThreshold *string `json:"securityAlertsThreshold,omitempty" tf:"security_alerts_threshold,omitempty"`

	// The name of a code scanning tool.
	Tool *string `json:"tool,omitempty" tf:"tool,omitempty"`
}

type RequiredCodeScanningToolParameters struct {

	// The severity level at which code scanning results that raise alerts block a reference update. Can be one of: `none`, `errors`, `errors_and_warnings`, `all`.
	// +kubebuilder:validation:Optional
	AlertsThreshold *string `json:"alertsThreshold" tf:"alerts_threshold,omitempty"`

	// The severity level at which code scanning results that raise security alerts block a reference update. Can be one of: `none`, `critical`, `high_or_higher`, `medium_or_higher`, `all`.
	// +kubebuilder:validation:Optional
	SecurityAlertsThreshold *string `json:"securityAlertsThreshold" tf:"security_alerts_threshold,omitempty"`

	// The name of a code scanning tool.
	// +kubebuilder:validation:Optional
	Tool *string `json:"tool" tf:"tool,omitempty"`
}

type RequiredStatusChecksInitParameters struct {

	// Status checks that are required. Several can be defined.
	RequiredCheck []RequiredCheckInitParameters `json:"requiredCheck,omitempty" tf:"required_check,omitempty"`

	// Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to `false`.
	StrictRequiredStatusChecksPolicy *bool `json:"strictRequiredStatusChecksPolicy,omitempty" tf:"strict_required_status_checks_policy,omitempty"`
}

type RequiredStatusChecksObservation struct {

	// Status checks that are required. Several can be defined.
	RequiredCheck []RequiredCheckObservation `json:"requiredCheck,omitempty" tf:"required_check,omitempty"`

	// Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to `false`.
	StrictRequiredStatusChecksPolicy *bool `json:"strictRequiredStatusChecksPolicy,omitempty" tf:"strict_required_status_checks_policy,omitempty"`
}

type RequiredStatusChecksParameters struct {

	// Status checks that are required. Several can be defined.
	// +kubebuilder:validation:Optional
	RequiredCheck []RequiredCheckParameters `json:"requiredCheck" tf:"required_check,omitempty"`

	// Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to `false`.
	// +kubebuilder:validation:Optional
	StrictRequiredStatusChecksPolicy *bool `json:"strictRequiredStatusChecksPolicy,omitempty" tf:"strict_required_status_checks_policy,omitempty"`
}

type RequiredWorkflowInitParameters struct {

	// The path to the workflow YAML definition file.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The ref (branch or tag) of the workflow file to use.
	Ref *string `json:"ref,omitempty" tf:"ref,omitempty"`

	// The repository in which the workflow is defined.
	RepositoryID *int64 `json:"repositoryId,omitempty" tf:"repository_id,omitempty"`
}

type RequiredWorkflowObservation struct {

	// The path to the workflow YAML definition file.
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// The ref (branch or tag) of the workflow file to use.
	Ref *string `json:"ref,omitempty" tf:"ref,omitempty"`

	// The repository in which the workflow is defined.
	RepositoryID *int64 `json:"repositoryId,omitempty" tf:"repository_id,omitempty"`
}

type RequiredWorkflowParameters struct {

	// The path to the workflow YAML definition file.
	// +kubebuilder:validation:Optional
	Path *string `json:"path" tf:"path,omitempty"`

	// The ref (branch or tag) of the workflow file to use.
	// +kubebuilder:validation:Optional
	Ref *string `json:"ref,omitempty" tf:"ref,omitempty"`

	// The repository in which the workflow is defined.
	// +kubebuilder:validation:Optional
	RepositoryID *int64 `json:"repositoryId" tf:"repository_id,omitempty"`
}

type RequiredWorkflowsInitParameters struct {

	// Actions workflows that are required. Several can be defined.
	RequiredWorkflow []RequiredWorkflowInitParameters `json:"requiredWorkflow,omitempty" tf:"required_workflow,omitempty"`
}

type RequiredWorkflowsObservation struct {

	// Actions workflows that are required. Several can be defined.
	RequiredWorkflow []RequiredWorkflowObservation `json:"requiredWorkflow,omitempty" tf:"required_workflow,omitempty"`
}

type RequiredWorkflowsParameters struct {

	// Actions workflows that are required. Several can be defined.
	// +kubebuilder:validation:Optional
	RequiredWorkflow []RequiredWorkflowParameters `json:"requiredWorkflow" tf:"required_workflow,omitempty"`
}

type RulesInitParameters struct {

	// Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applies to rulesets with target `branch`.
	BranchNamePattern []BranchNamePatternInitParameters `json:"branchNamePattern,omitempty" tf:"branch_name_pattern,omitempty"`

	// Parameters to be used for the commit_author_email_pattern rule.
	CommitAuthorEmailPattern []CommitAuthorEmailPatternInitParameters `json:"commitAuthorEmailPattern,omitempty" tf:"commit_author_email_pattern,omitempty"`

	// Parameters to be used for the commit_message_pattern rule.
	CommitMessagePattern []CommitMessagePatternInitParameters `json:"commitMessagePattern,omitempty" tf:"commit_message_pattern,omitempty"`

	// Parameters to be used for the committer_email_pattern rule.
	CommitterEmailPattern []CommitterEmailPatternInitParameters `json:"committerEmailPattern,omitempty" tf:"committer_email_pattern,omitempty"`

	// Only allow users with bypass permission to create matching refs.
	Creation *bool `json:"creation,omitempty" tf:"creation,omitempty"`

	// Only allow users with bypass permissions to delete matching refs.
	Deletion *bool `json:"deletion,omitempty" tf:"deletion,omitempty"`

	// Prevent users with push access from force pushing to branches.
	NonFastForward *bool `json:"nonFastForward,omitempty" tf:"non_fast_forward,omitempty"`

	// Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
	PullRequest []PullRequestInitParameters `json:"pullRequest,omitempty" tf:"pull_request,omitempty"`

	// Choose which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated.
	RequiredCodeScanning []RequiredCodeScanningInitParameters `json:"requiredCodeScanning,omitempty" tf:"required_code_scanning,omitempty"`

	// Prevent merge commits from being pushed to matching branches.
	RequiredLinearHistory *bool `json:"requiredLinearHistory,omitempty" tf:"required_linear_history,omitempty"`

	// Commits pushed to matching branches must have verified signatures.
	RequiredSignatures *bool `json:"requiredSignatures,omitempty" tf:"required_signatures,omitempty"`

	// Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed.
	RequiredStatusChecks []RequiredStatusChecksInitParameters `json:"requiredStatusChecks,omitempty" tf:"required_status_checks,omitempty"`

	// Choose which Actions workflows must pass before branches can be merged into a branch that matches this rule.
	RequiredWorkflows []RequiredWorkflowsInitParameters `json:"requiredWorkflows,omitempty" tf:"required_workflows,omitempty"`

	// Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applies to rulesets with target `tag`.
	TagNamePattern []TagNamePatternInitParameters `json:"tagNamePattern,omitempty" tf:"tag_name_pattern,omitempty"`

	// Only allow users with bypass permission to update matching refs.
	Update *bool `json:"update,omitempty" tf:"update,omitempty"`
}

type RulesObservation struct {

	// Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applies to rulesets with target `branch`.
	BranchNamePattern []BranchNamePatternObservation `json:"branchNamePattern,omitempty" tf:"branch_name_pattern,omitempty"`

	// Parameters to be used for the commit_author_email_pattern rule.
	CommitAuthorEmailPattern []CommitAuthorEmailPatternObservation `json:"commitAuthorEmailPattern,omitempty" tf:"commit_author_email_pattern,omitempty"`

	// Parameters to be used for the commit_message_pattern rule.
	CommitMessagePattern []CommitMessagePatternObservation `json:"commitMessagePattern,omitempty" tf:"commit_message_pattern,omitempty"`

	// Parameters to be used for the committer_email_pattern rule.
	CommitterEmailPattern []CommitterEmailPatternObservation `json:"committerEmailPattern,omitempty" tf:"committer_email_pattern,omitempty"`

	// Only allow users with bypass permission to create matching refs.
	Creation *bool `json:"creation,omitempty" tf:"creation,omitempty"`

	// Only allow users with bypass permissions to delete matching refs.
	Deletion *bool `json:"deletion,omitempty" tf:"deletion,omitempty"`

	// Prevent users with push access from force pushing to branches.
	NonFastForward *bool `json:"nonFastForward,omitempty" tf:"non_fast_forward,omitempty"`

	// Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
	PullRequest []PullRequestObservation `json:"pullRequest,omitempty" tf:"pull_request,omitempty"`

	// Choose which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated.
	RequiredCodeScanning []RequiredCodeScanningObservation `json:"requiredCodeScanning,omitempty" tf:"required_code_scanning,omitempty"`

	// Prevent merge commits from being pushed to matching branches.
	RequiredLinearHistory *bool `json:"requiredLinearHistory,omitempty" tf:"required_linear_history,omitempty"`

	// Commits pushed to matching branches must have verified signatures.
	RequiredSignatures *bool `json:"requiredSignatures,omitempty" tf:"required_signatures,omitempty"`

	// Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed.
	RequiredStatusChecks []RequiredStatusChecksObservation `json:"requiredStatusChecks,omitempty" tf:"required_status_checks,omitempty"`

	// Choose which Actions workflows must pass before branches can be merged into a branch that matches this rule.
	RequiredWorkflows []RequiredWorkflowsObservation `json:"requiredWorkflows,omitempty" tf:"required_workflows,omitempty"`

	// Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applies to rulesets with target `tag`.
	TagNamePattern []TagNamePatternObservation `json:"tagNamePattern,omitempty" tf:"tag_name_pattern,omitempty"`

	// Only allow users with bypass permission to update matching refs.
	Update *bool `json:"update,omitempty" tf:"update,omitempty"`
}

type RulesParameters struct {

	// Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applies to rulesets with target `branch`.
	// +kubebuilder:validation:Optional
	BranchNamePattern []BranchNamePatternParameters `json:"branchNamePattern,omitempty" tf:"branch_name_pattern,omitempty"`

	// Parameters to be used for the commit_author_email_pattern rule.
	// +kubebuilder:validation:Optional
	CommitAuthorEmailPattern []CommitAuthorEmailPatternParameters `json:"commitAuthorEmailPattern,omitempty" tf:"commit_author_email_pattern,omitempty"`

	// Parameters to be used for the commit_message_pattern rule.
	// +kubebuilder:validation:Optional
	CommitMessagePattern []CommitMessagePatternParameters `json:"commitMessagePattern,omitempty" tf:"commit_message_pattern,omitempty"`

	// Parameters to be used for the committer_email_pattern rule.
	// +kubebuilder:validation:Optional
	CommitterEmailPattern []CommitterEmailPatternParameters `json:"committerEmailPattern,omitempty" tf:"committer_email_pattern,omitempty"`

	// Only allow users with bypass permission to create matching refs.
	// +kubebuilder:validation:Optional
	Creation *bool `json:"creation,omitempty" tf:"creation,omitempty"`

	// Only allow users with bypass permissions to delete matching refs.
	// +kubebuilder:validation:Optional
	Deletion *bool `json:"deletion,omitempty" tf:"deletion,omitempty"`

	// Prevent users with push access from force pushing to branches.
	// +kubebuilder:validation:Optional
	NonFastForward *bool `json:"nonFastForward,omitempty" tf:"non_fast_forward,omitempty"`

	// Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
	// +kubebuilder:validation:Optional
	PullRequest []PullRequestParameters `json:"pullRequest,omitempty" tf:"pull_request,omitempty"`

	// Choose which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated.
	// +kubebuilder:validation:Optional
	RequiredCodeScanning []RequiredCodeScanningParameters `json:"requiredCodeScanning,omitempty" tf:"required_code_scanning,omitempty"`

	// Prevent merge commits from being pushed to matching branches.
	// +kubebuilder:validation:Optional
	RequiredLinearHistory *bool `json:"requiredLinearHistory,omitempty" tf:"required_linear_history,omitempty"`

	// Commits pushed to matching branches must have verified signatures.
	// +kubebuilder:validation:Optional
	RequiredSignatures *bool `json:"requiredSignatures,omitempty" tf:"required_signatures,omitempty"`

	// Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed.
	// +kubebuilder:validation:Optional
	RequiredStatusChecks []RequiredStatusChecksParameters `json:"requiredStatusChecks,omitempty" tf:"required_status_checks,omitempty"`

	// Choose which Actions workflows must pass before branches can be merged into a branch that matches this rule.
	// +kubebuilder:validation:Optional
	RequiredWorkflows []RequiredWorkflowsParameters `json:"requiredWorkflows,omitempty" tf:"required_workflows,omitempty"`

	// Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applies to rulesets with target `tag`.
	// +kubebuilder:validation:Optional
	TagNamePattern []TagNamePatternParameters `json:"tagNamePattern,omitempty" tf:"tag_name_pattern,omitempty"`

	// Only allow users with bypass permission to update matching refs.
	// +kubebuilder:validation:Optional
	Update *bool `json:"update,omitempty" tf:"update,omitempty"`
}

type TagNamePatternInitParameters struct {

	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type TagNamePatternObservation struct {

	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type TagNamePatternParameters struct {

	// How this rule will appear to users.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// If true, the rule will fail if the pattern matches.
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// The pattern to match with.
	// +kubebuilder:validation:Optional
	Pattern *string `json:"pattern" tf:"pattern,omitempty"`
}

// OrganizationRulesetSpec defines the desired state of OrganizationRuleset
type OrganizationRulesetSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     OrganizationRulesetParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider OrganizationRulesetInitParameters `json:"initProvider,omitempty"`
}

// OrganizationRulesetStatus defines the observed state of OrganizationRuleset.
type OrganizationRulesetStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        OrganizationRulesetObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// OrganizationRuleset is the Schema for the OrganizationRulesets API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,github}
type OrganizationRuleset struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.enforcement) || (has(self.initProvider) && has(self.initProvider.enforcement))",message="spec.forProvider.enforcement is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.rules) || (has(self.initProvider) && has(self.initProvider.rules))",message="spec.forProvider.rules is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.target) || (has(self.initProvider) && has(self.initProvider.target))",message="spec.forProvider.target is a required parameter"
	Spec   OrganizationRulesetSpec   `json:"spec"`
	Status OrganizationRulesetStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// OrganizationRulesetList contains a list of OrganizationRulesets
type OrganizationRulesetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []OrganizationRuleset `json:"items"`
}

// Repository type metadata.
var (
	OrganizationRuleset_Kind             = "OrganizationRuleset"
	OrganizationRuleset_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: OrganizationRuleset_Kind}.String()
	OrganizationRuleset_KindAPIVersion   = OrganizationRuleset_Kind + "." + CRDGroupVersion.String()
	OrganizationRuleset_GroupVersionKind = CRDGroupVersion.WithKind(OrganizationRuleset_Kind)
)

func init() {
	SchemeBuilder.Register(&OrganizationRuleset{}, &OrganizationRulesetList{})
}
